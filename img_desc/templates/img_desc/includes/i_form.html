{% load otree static %}

<script>
    window.interpreter_title = {{ session.vars.interpreter_title | json }}
    window.interpreter_choices = {{ session.vars.interpreter_choices | json }}
</script>
<div id="app">
    {% verbatim %}
  

    <form @submit.prevent="checkChoices">
        <input type="hidden" name="interpreter_decision" :value="JSON.stringify(sweets)">
        <input type="hidden" v-model="startTime" name="start_decision_time">
        <input type="hidden" v-model="endTime" name="end_decision_time">
        <input type="hidden" v-model="durationInSeconds" name="decision_seconds">
        <table class="table">
            <thead>
                <tr>
                    <th scope="col">{{interpreter_title}}</th>
                    <th scope="col">Yes</th>
                    <th scope="col">No</th>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(sweet, index) in sweets" :key="index">
                    <td>{{ sweet.name }}</td>
                    <td><input type="radio" v-model="sweet.choice" :value="true" @change="resetError"></td>
                    <td><input type="radio" v-model="sweet.choice" :value="false" @change="resetError"></td>

                </tr>
            </tbody>
        </table>

        <button :disabled="!allChoicesMade" type="button" @click="checkChoices" class="btn btn-primary">Next</button>


        <p v-if="error" class="alert alert-danger my-3">Error: please, check your answers!</p>
    </form>
    {% endverbatim %}
</div>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
    const app = Vue.createApp({
        data() {
            const sweets = window.interpreter_choices.map((name, index) => ({ name: name, choice: null }));

            return {
                startTime: new Date().toISOString(),  // ISO string format "2023-07-19T16:14:33.789Z"
                endTime: null,
                durationInSeconds: null,
                interpreter_title: window.interpreter_title,
                sweets: sweets,
                error: false,
            }
        },
        methods: {
            resetError() {
                this.error = false;
            },
            checkChoices() {
                this.endTime = new Date().toISOString();
                this.durationInSeconds = (new Date(this.endTime) - new Date(this.startTime)) / 1000;

                this.$nextTick(() => {
                    
                    // After the next DOM update cycle
                    {# $('#form').submit() #}
                });

                $('#form').submit()

            },
        },
        computed: {
            allChoicesMade() {
                return this.sweets.every(sweet => sweet.choice !== null);
            }
        }
    })
    app.mount('#app')
</script>